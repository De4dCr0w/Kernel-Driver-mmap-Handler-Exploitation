/*************************************************************************
	> File Name: vul1.c
	> Author: de4dcr0w
	> Mail: sa516203@mail.ustc.edu.cn 
	> Created Time: Mon 07 May 2018 01:11:30 AM PDT
 ************************************************************************/

#include <linux/ioctl.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/errno.h>
#include <linux/types.h>
#include <linux/fcntl.h>
#include <linux/cdev.h>
#include <linux/version.h>
#include <linux/vmalloc.h>
#include <linux/ctype.h>
#include <linux/pagemap.h>
#include <linux/mm.h>
#include <asm/xen/page.h>

#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/skbuff.h>
#include <linux/delay.h>
#include <asm/page.h>


#define driver_major 244
#define driver_minor 0

int size = 0x1000; 
struct char_dev
{
	struct cdev cdev;
};

struct char_dev *char_devs;


static int dev_open(struct inode *inodep, struct file *filep) 
{ 
	printk(KERN_INFO "MWR: Device has been opened\n"); 
	filep->private_data = kzalloc(size, GFP_KERNEL); 
	if (filep->private_data == NULL) 
		return -1; 
	return 0; 
} 

int simple_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf) 
{ 
	struct page *page = NULL; 
	unsigned long offset; 
	printk(KERN_NOTICE "MWR: simple_vma_fault\n"); 
	printk(KERN_NOTICE "MWR: vmf->pgoff: %lx, vma->vm_pgoff: %lx, sum: %lx, PAGE_SHIFT: %x\n", (unsigned long)vmf->pgoff, (unsigned long)vma->vm_pgoff, ((vmf->pgoff << PAGE_SHIFT) + (vma->vm_pgoff << PAGE_SHIFT)), PAGE_SHIFT); 
	offset = (((unsigned long)vmf->address - vma->vm_start) + (vma->vm_pgoff << PAGE_SHIFT));
	if (offset > PAGE_SIZE << 4) 
		goto nopage_out; 
	page = virt_to_page(vma->vm_private_data + offset);

	vmf->page = page; 
	get_page(page); 
nopage_out: 
	return 0; 
}

void simple_vma_open(struct vm_area_struct *vma){

printk(KERN_NOTICE "simple VMA open virt %lx,phys %lx/n",vma->vm_start,vma->vm_pgoff<<PAGE_SHIFT);


}
void simple_vma_close(struct vm_area_struct *vma){
	
printk(KERN_NOTICE "Simple VMA close./n");

}
static struct vm_operations_struct simple_remap_vm_ops = { 
	.open = simple_vma_open, 
	.close = simple_vma_close, 
	.fault = simple_vma_fault, 
};

static int simple_vma_ops_mmap(struct file *filp, struct vm_area_struct *vma) 
{ 
	unsigned long size = vma->vm_end - vma->vm_start;
	printk(KERN_INFO "MWR: Device simple_vma_ops_mmap\n"); 
	vma->vm_private_data = filp->private_data; 
	vma->vm_ops = &simple_remap_vm_ops; 
	simple_vma_open(vma); 
	if(size > 0x1000)
	{
		printk(KERN_INFO "MWR: mmap failed, requested too large a chunk of memory\n");
		return -EAGAIN;
	}
	printk(KERN_INFO "MWR: Device mmap OK\n"); 
	return 0; 
}

int dev_release(struct inode *inode, struct file *filp)
{
	    return 0;
}

static struct file_operations fops = { 
	.open = dev_open, 
	.mmap = simple_vma_ops_mmap,
	.release = dev_release, 
}; 


void dev_exit_module(void)
{
	printk(KERN_ALERT "GoodBye!Vul1-driver\n");
	dev_t dev = MKDEV(driver_major,driver_minor);
	if(char_devs)
	{
		cdev_del(&char_devs->cdev);
		kfree(char_devs);
	}
	unregister_chrdev_region(dev,1);
}

int dev_init_module(void)
{
    int result;
    printk("driver_init_module~\n");
    dev_t dev = MKDEV(driver_major,driver_minor);
    result = register_chrdev_region(dev,1,"DRIVER-Vul1");
    if(result < 0)
    {
        printk(KERN_WARNING "driver: can't get major %d\n",driver_major);
        goto fail;
    }
    char_devs = kmalloc(sizeof(struct char_dev),GFP_KERNEL);
    if(!char_devs)
    {
        result = -ENOMEM;
        goto fail;
    }
    memset(char_devs,0,sizeof(struct char_dev));
    cdev_init(&char_devs->cdev,&fops);
    char_devs->cdev.ops = &fops;
    result = cdev_add(&char_devs->cdev, dev, 1);
    return 0;
fail:
    dev_exit_module();
    return 0;
}

module_init(dev_init_module);
module_exit(dev_exit_module);
MODULE_LICENSE("GPL");
